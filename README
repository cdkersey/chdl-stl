CHDL Standard Template Library
==============================

The CHDL STL is an auxilliary library of useful components that are considered
secondary to the CHDL core. These may be distributed alongside CHDL but retain
an identity as a separately-maintained, separately-tested entity, depending on
the core features provided by CHDL.

Contents
--------

  1 API Documentation
    1.1 Aggregate Types
      1.1.1 strtype
      1.1.2 ag
    1.2 Queue
    1.3 Stack
    1.4 Map
    1.5 Network
     1.5.1 flit
     1.5.2 Buffer
     1.5.3 Arbiter
     1.5.4 Router
    1.6 Counter
    1.7 Linear Feedback Shift Register
  2 Examples

1 API Documentation
-------------------

1.1 Aggregate Types
-------------------

It is convenient when using CHDL to bundle together CHDL types into C++ structs
and classes, so that collections of signals and functions operating on them may
be passed all of these sinals as a bundle. The downside is that this collection
of signals cannot then be easily, collectively tapped or operated on by CHDL
standard library functions without this functionality being added manually for
each such struct.

C++ does not really provide the level of reflection needed to allow the
creation of such utility functions as conversions to bvec at compile time for
arbitrary structs, or if it does the author is not aware of it. Enter chdl::ag
and the surrounding ecosystem of types, a way to get around this problem by
replacing C++ structs with an equivalent template type.

For example, say you had a library that used sign-exponent-mantissa floating
point numbers. It may really be more appropriate to build these as a C++ class
templates, but for the purposes of our example you could implement it using a
CHDL aggregate (using C++11 alias templates) as:

  template <unsigned E, unsigned M> using Float =
    ag<STRTYPE("sign"),     node,
    ag<STRTYPE("exponent"), bvec<E>,
    ag<STRTYPE("mantissa"), bvec<M> > > >;

The STRTYPE() macro converts an input string to a type, so that it may be
evaluated and compared at compile time. Members of Float can be extracted using
the Lookup<> function:

  template <unsigned E, unsigned M> Float<E, M> Neg(Float<E, M> &in) {
    Float<E, M> out;
    Lookup<STRTYPE("sign")>(out) = !Lookup<STRTYPE("sign")>(in);
    Lookup<STRTYPE("exponent")>(out) = Lookup<STRTYPE("exponent")>(in);
    Lookup<STRTYPE("mantissa")>(out) = Lookup<STRTYPE("mantissa")>(in);

    return out;
  }

This is rather verbose, but is made somewhat better by using the "_" macro:

  template <unsigned E, unsigned M> Float<E, M> Neg(Float<E, M> &in) {
    Float<E, M> out;
    _(out, "sign") = !_(in, "sign");
    _(out, "exponent") = _(in, "exponent");
    _(out, "mantissa") = _(in, "mantissa");
    
    return out;
  }

Of course, this is a potentially contentuous macro name, and in the event of a
conflict, it can be disabled by defining CHDL_AG_DISABLE_UNDERSCORE before
including ag.h.

1.1.1 strtype<C, NEXT>
----------------------

Description:

  A template that encodes a string as a linked list of types.

1.1.2 ag<NAME, T, NEXT>
-----------------------

Description:

  A template that encodes a structured data type as a linked list of types.

1.2 Queue
---------

Description:

  A 2^SZ-entry queue

  template <typename T, unsigned SZ>
    T Queue(T input, node push, node pop, bvec<SZ + 1> &sz);

  Template parameters:
    T  - The type of objects in the queue.
    SZ - LOG2 of the number of entries in the queue.

  Inputs:
    input - The item to be enqueued during any cycle in which push is high.
    push  - The "push" command.
    pop   - The "pop" command.

  Outputs:
    sz      - Current number of items in the queue.
    returns - The head of the queue.

1.3 Stack
---------

Description:

  A 2^SZ-entry stack

  template <typename T, unsigned SZ>
    T Stack(T input, node push, node pop, bvec<SZ + 1> &sz);

  Template parameters:
    T  - The type of objects in the stack.
    SZ - LOG2 of the number of entries in the stack.

  Inputs:
    input - The item to be pushed during any cycle in which push is high.
    push  - The "push" command.
    pop   - The "pop" command.

  Outputs:
    sz      - Current number of items in the stack.
    returns - The contents of the top of the stack.

1.4 Map
-------

Description:

  A SZ-entry fully-associative memory holding key/value pairs

  Template parameters:
    K  - Number of bits in key.
    V  - Number of bits in value.
    SZ - Number of entries.

  Inputs:
    qkey  - The key for the primary output.
    dkey  - The key to write or erase.
    d     - The value to be written.
    write - Perform write.
    erase - Remove entry with key "dkey" from map.

  Outputs:
    full    - There are no entries remaining.
    inmap   - There is an entry with key "qkey".
    returns - The value stored at key "qkey".

1.5 Network
-----------

1.5.1 flit
----------

1.5.2 Buffer
------------

1.5.3 Arbiter
-------------

1.5.4 Router
------------

1.6 Counter
-----------

"Counter" exists to add simple stat-gathering counters to any design. These can
be of arbitrary size, but they default to 32 bits. A Counter will automatically
create a CHDL tap, so for example:

  Counter("x_transitions", x != Reg(x));

is all that is required to add "counter_x_transitions" to the output .vcd file
when simulating.

1.7 Linear Feedback Shift Register
----------------------------------

Linear feedback shift registers are a well-known inexpensive hardware random
number generator. Even in their most basic form, an N-bit LFSR will have a
2^N - 1 cycle length if the parameters are well-chosen (corresponding to what
is known as a primitive trinomial).

The CHDL STL LFSR can perform multiple iterations per cycle, producing multiple
bits of output. The period of this new configuration is simply (2^N - 1)/M,
with the caveat that the repetitions may be bit shifted. Due to its efficiency,
large periods can be obtained with a small amount of circuitry. With 65 bits of
state, a circuit can produce a large number of pseudorandom bits for decades
without repeating itself.

Some selected primitive trinomials taken from the list distributed with the
libecc source (of course with no warranty). The time given is the amount of
time it would take, assuming the LFSR is used to produce 32 bits of output per
nanosecond, for the LFSR to begin repeating itself:

                   N  | TAP | Log10(Period) | Time @32b/ns
                ------+-----+---------------+--------------
                   17 |   3 |       5.1     |      4 us
                   33 |  10 |       9.9     |     268 ms
                   65 |  18 |      19.5     |    36 years
                  129 |   5 |      38.8     |  6.7e20 years
                  257 |  12 |      77.3     |  2.2e50 years
                  513 |  85 |     154.4     |  2.6e127 years
                 1023 |   7 |     307.9     |  8.9e280 years

This has many uses. In the following example, the outputs of four LFSRs
(presumed to be uniformly distributed) are summed to produce a result with an
approximately normal distribution:

  bvec<8> norm(node advance) {
    bvec<6> l0(Lfsr<6, 33, 10, 1>(advance)), l1(Lfsr<6, 34, 7, 4>(advance)),
            l2(Lfsr<6, 33, 13, 2>(advance)), l3(Lfsr<6, 35, 2, 8>(advance));

    return Zext<8>(l0) + Zext<8>(l1) + Zext<8>(l2) + Zext<8>(l3);
  }

2 Examples
----------
